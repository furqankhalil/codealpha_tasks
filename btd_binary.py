# -*- coding: utf-8 -*-
"""BTD_Binary.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1zXpQp37l8I3r9Gz1da2EtdL-q8tIuMbG
"""

import os
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from PIL import Image
import random
import math

import tensorflow as tf
from tensorflow.keras.preprocessing.image import ImageDataGenerator
from tensorflow.keras.models import Sequential
from keras import regularizers
from tensorflow.keras.layers import Conv2D, MaxPooling2D, AveragePooling2D, Flatten, Dense, Dropout,BatchNormalization
from tensorflow.keras.optimizers import Adam
from sklearn.metrics import classification_report, confusion_matrix
from tensorflow.keras.models import Sequential

from google.colab import drive
drive.mount('/content/drive')

print(os.listdir('/content/drive/MyDrive/Brain Tumour Detection/Brain-Tumor-Classification-DataSet'))

# Define directory paths (replace with yours)
train_dir = "/content/drive/MyDrive/Brain Tumour Detection/Brain-Tumor-Classification-DataSet/Training"
no_tumor_dir = os.path.join(train_dir, "no_tumor")
pituitary_tumor_dir = os.path.join(train_dir, "pituitary_tumor")

# Get random image paths from each category (ensure correct directories)
no_tumor_images = random.sample(os.listdir(no_tumor_dir), 1)
pituitary_tumor_images = random.sample(os.listdir(pituitary_tumor_dir), 1)

# Load images using PIL for wider format compatibility
no_tumor_path = os.path.join(no_tumor_dir, no_tumor_images[0])
pituitary_tumor_path = os.path.join(pituitary_tumor_dir, pituitary_tumor_images[0])
no_tumor_img = Image.open(no_tumor_path)
pituitary_tumor_img = Image.open(pituitary_tumor_path)

# Prepare a single figure for side-by-side display
plt.figure(figsize=(10, 5))  # Adjust for image size and desired layout

# Subplot for No Tumor image
plt.subplot(1, 2, 1)  # Create first subplot
plt.imshow(no_tumor_img, cmap='gray')
plt.title('No Tumour')
plt.axis('off')  # Hide axes for cleaner presentation (optional)

# Subplot for Pituitary Tumor image
plt.subplot(1, 2, 2)  # Create second subplot
plt.imshow(pituitary_tumor_img, cmap='gray')
plt.title('Pituitary Tumour')
plt.axis('off')  # Hide axes for cleaner presentation (optional)

plt.tight_layout()  # Adjust spacing between subplots
plt.show()

train_dir = "/content/drive/MyDrive/Brain Tumour Detection/Brain-Tumor-Classification-DataSet/Training"
train_pituitary = (os.listdir(os.path.join(train_dir, "pituitary_tumor")))
train_no_tumor = (os.listdir(os.path.join(train_dir, "no_tumor")))

test_dir = "/content/drive/MyDrive/Brain Tumour Detection/Brain-Tumor-Classification-DataSet/Testing"
test_pituitary = (os.listdir(os.path.join(test_dir, "pituitary_tumor")))
test_no_tumor = (os.listdir(os.path.join(test_dir, "no_tumor")))

# Define the image size and batch size
img_size = (150, 150)
batch_size = 32

# Create an ImageDataGenerator for data augmentation and normalization
train_datagen = ImageDataGenerator(
    rescale=1./255,
)

test_datagen = ImageDataGenerator(
    rescale=1./255
)
# Load and preprocess the training data
train_generator = train_datagen.flow_from_directory(
    train_dir,
    target_size=img_size,
    color_mode='grayscale',
    batch_size=batch_size,
    class_mode='binary',

)

# Load and preprocess the testing data
test_generator = test_datagen.flow_from_directory(
    test_dir,
    target_size=img_size,
    color_mode='grayscale',
    batch_size=batch_size,
    class_mode='binary',

    )

model = Sequential()

model.add(Conv2D(32, (3, 3), activation='relu', input_shape=(150, 150,1)))
model.add(MaxPooling2D((2, 2)))

model.add(Conv2D(64, (3, 3), activation='relu'))
model.add(MaxPooling2D((2, 2)))

model.add(Conv2D(128, (3, 3), activation='relu'))
model.add(MaxPooling2D((2, 2)))

model.add(Flatten())

model.add(Dense(128, activation='relu'))
model.add(Dropout(0.5))

model.add(Dense(1, activation='sigmoid'))

model.summary()

model.compile(loss='binary_crossentropy', optimizer='Adam', metrics=['accuracy'])

from keras.callbacks import EarlyStopping

early_stopping = EarlyStopping(monitor='val_loss', patience=5, restore_best_weights=True)


model.compile(optimizer='Adam', loss='binary_crossentropy', metrics=['accuracy'])
history = model.fit(
    train_generator,
    validation_data=(test_generator),
    batch_size=batch_size,
    verbose=1,
    epochs=10,
)

evaluation_result = model.evaluate(test_generator)

# This will print the evaluation metrics (e.g., loss and accuracy)
print("Evaluation Result:", evaluation_result)

predictions = model.predict(test_generator)

predictions = model.predict(test_generator)
y_pred = (predictions > 0.5).astype(int)

#  "Accuracy Plot"
plt.figure(figsize=(8,5))
plt.plot(history.history['accuracy'])
plt.plot(history.history['val_accuracy'])
plt.title('model accuracy')
plt.ylabel('accuracy')
plt.xlabel('epoch')
plt.legend(['train', 'validation'], loc='upper left')
plt.show()

# "Loss Plot"
plt.figure(figsize=(8,5))
plt.plot(history.history['loss'])
plt.plot(history.history['val_loss'])
plt.title('model loss')
plt.ylabel('loss')
plt.xlabel('epoch')
plt.legend(['train', 'validation'], loc='upper left')
plt.show()

true_labels = test_generator.classes

# Calculate confusion matrix
confusion_mtx = confusion_matrix(true_labels, y_pred)
confusion_mtx

labels = ['no_tumor','pituitary_tumor']

plt.figure(figsize=(5, 5))
sns.heatmap(confusion_mtx, annot=True, fmt='d', cmap='Blues', cbar=False, square=True, xticklabels=labels, yticklabels=labels)
plt.xlabel('Predicted')
plt.ylabel('True')
plt.title('Confusion Matrix')
plt.show()

print(classification_report(true_labels, y_pred, target_names=['no_tumor','pituitary_tumor']))

model.save('brain_tumor_model.h5')

from tensorflow.keras.models import load_model
import cv2
import numpy as np

# Load the saved model
loaded_model = load_model('/content/brain_tumor_model.h5')

# Function to preprocess the input image
def preprocess_image(image_path):
    # Read the image using OpenCV
    image = cv2.imread(image_path)
    # Convert the image to grayscale
    gray_image = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
    # Resize the image to the same dimensions as your training data
    resized_image = cv2.resize(gray_image, (150, 150))
    # Normalize the image pixel values to be in the range [0, 1]
    normalized_image = resized_image / 255.0
    # Reshape the image to match the input shape of your model
    input_image = np.expand_dims(normalized_image, axis=-1)
    input_image = np.expand_dims(input_image, axis=0)
    return input_image

# Function to make predictions
def predict_image(model, image_path):
    # Preprocess the input image
    input_image = preprocess_image(image_path)
    # Make predictions using the loaded model
    predictions = model.predict(input_image)
    # Assuming binary classification, if predictions[0][0] > 0.5, it belongs to class 1, else class 0
    if predictions[0][0] > 0.5:
        print("Prediction: Tumor Present")
    else:
        print("Prediction: No Tumor")

# Path to the single image you want to predict (replace with your image path)
image_path = '/content/drive/MyDrive/Brain Tumour Detection/Brain-Tumor-Classification-DataSet/Training/pituitary_tumor/p (106).jpg'

# Call the predict_image function with the loaded model and image path
predict_image(loaded_model, image_path)